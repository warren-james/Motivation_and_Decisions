remaining_weeks_1 = total_weeks- shared_weeks
shared_weeks_2 = min(fst_remaining_weeks_j, fst_remaining_weeks_k)
remaining_weeks_2 = remaining_weeks_1 - shared_weeks_2
total_cost - (total_cost*(shared_weeks/total_weeks))*length(c(weeks_w, weeks_k, weeks_j, weeks_l))
cost_shared_weeks = total_cost*(shared_weeks/total_weeks)
cost_shared_weeks_pp = cost_shared_weeks/length(c(weeks_w, weeks_k, weeks_j, weeks_l))
remainig_cost = total_cost - cost_shared_weeks
cost_shared_weeks_2 = remaining_cost*(shared_weeks_2/remaining_week_1)
remainig_cost = total_cost - cost_shared_weeks
cost_shared_weeks_2 = remaining_cost*(shared_weeks_2/remaining_week_1)
remaining_cost = total_cost - cost_shared_weeks
cost_shared_weeks_2 = remaining_cost*(shared_weeks_2/remaining_week_1)
# now get the cost of the new shared weeks
cost_shared_weeks_2 = remaining_cost*(shared_weeks_2/remaining_weeks_1)
cost_shared_weeks_2_pp = cost_shared_weeks_2/length(c(fst_remaining_weeks_k,fst_remaining_weeks_j))
w_owes_2 = cost_shared_weeks_pp
l_owes_2 = cost_shared_weeks_pp
k_owes_2 = cost_shared_weeks_pp + cost_shared_weeks_2_pp
j_owes_2 = cost_shared_weeks_pp + cost_shared_weeks_2_pp + (total_cost - (cost_shared_weeks_pp + cost_shared_weeks_2_pp))
remaining_cost_2 = remaining_cost-cost_shared_weeks_2
j_owes_2 = cost_shared_weeks_pp + cost_shared_weeks_2_pp + remaining_cost_2
# tidy
rm(cost_shared_weeks, cost_shared_weeks_2, cost_shared_weeks_2_pp, cost_shared_weeks_pp,
fst_remaining_weeks_j, fst_remaining_weeks_k, fst_remaining_weeks_l, fst_remaining_weeks_w,
remainig_cost, remaining_cost, remaining_cost_2, remaining_weeks_1, remaining_weeks_2,
shared_weeks, shared_weeks_2,
total_cost, total_weeks,
weeks_j, weeks_k, weeks_l, weeks_w)
# options
options(digits = 5)
# work out bills
# for 8th March 2018
elec_previous = 58242
elec_current = 59699
gas_previous = 5480
gas_current = 5888
gas = (((gas_current - gas_previous) * 39.4 * 1.02264/3.6) * 0.02763) + (113 * 0.25)
elec = ((elec_current - elec_previous) * 0.1586) + (113 * 0.18)
VAT = 0.05
total_cost = gas + elec + (gas + elec)*VAT
total_weeks = 12
w_weeks = total_weeks - 2
k_weeks = total_weeks - 1
l_weeks = total_weeks - 2
j_weeks = total_weeks
all_weeks = w_weeks + j_weeks + k_weeks + l_weeks
w_owes = total_cost*(w_weeks/all_weeks)
k_owes = total_cost*(k_weeks/all_weeks)
l_owes = total_cost*(l_weeks/all_weeks)
j_owes = total_cost*(j_weeks/all_weeks)
w_owes
k_owes
l_owes
j_owes
# total owed
total_owed = w_owes + k_owes + l_owes + j_owes
#### THIS DOESN'T WORK #####
# let's work it out properly
# tidy first
rm(VAT,elec,elec_current,elec_previous,gas,gas_current,gas_previous)
rm(all_weeks, total_owed)
temp_w = (total_cost/4)*(10/12)
temp_l = (total_cost/4)*(10/12)
temp_k = (toal_cost/4)*(11/12)
temp_k = (total_cost/4)*(11/12)
temp_k = ((total_cost-temp_w-temp_l)/4)*(1/2)
temp_k = ((total_cost-temp_w-temp_l)/2)*(1/2)
temp_k = ((total_cost-temp_w-temp_l)/2)
new_cost = total_cost -temp_w - temp_l
temp_k = (new_cost/2)*0.5
temp_k = (new_cost/2)*(1/3)
temp_k = (new_cost/2)*(11/12)
temp_k = (new_cost/2)*(1/2)
(2/2)*(1/2)
temp_w2 = (total_cost)*(10/(10+10+11+12))
temp_k = (total_cost/4)*(11/12)
weeks_w = total_weeks - 2
weeks_k = total_weeks - 1
weeks_j = total_weeks
weeks_l = total_weeks - 2
# total shared weeks
shared_weeks = min(weeks_w, weeks_k, weeks_j, weeks_l)
remaining_weeks_1 = total_weeks- shared_weeks
# everyone's cost for those shared weeks
cost_shared_weeks = total_cost*(shared_weeks/total_weeks)
cost_shared_weeks_pp = cost_shared_weeks/length(c(weeks_w, weeks_k, weeks_j, weeks_l))
remaining_cost = total_cost - cost_shared_weeks
# Is there a unique one left?
fst_remaining_weeks_w = weeks_w - shared_weeks
fst_remaining_weeks_k = weeks_k - shared_weeks
fst_remaining_weeks_j = weeks_j - shared_weeks
fst_remaining_weeks_l = weeks_l - shared_weeks
# can work out the people with only shared days now
w_owes_2 = cost_shared_weeks_pp
l_owes_2 = cost_shared_weeks_pp
# don't worry about working out those with 0
shared_weeks_2 = min(fst_remaining_weeks_j, fst_remaining_weeks_k)
remaining_weeks_2 = remaining_weeks_1 - shared_weeks_2
# now get the cost of the new shared weeks
cost_shared_weeks_2 = remaining_cost*(shared_weeks_2/remaining_weeks_1)
cost_shared_weeks_2_pp = cost_shared_weeks_2/length(c(fst_remaining_weeks_k,fst_remaining_weeks_j))
remaining_cost_2 = remaining_cost-cost_shared_weeks_2
k_owes_2 = cost_shared_weeks_pp + cost_shared_weeks_2_pp
j_owes_2 = cost_shared_weeks_pp + cost_shared_weeks_2_pp + remaining_cost_2
temp_w = (total_cost/4) * (10/12)
library(tidyverse)
library(rethinking)
dat <- data.frame(x = beta(100, 3, 1.8))
dat <- data.frame(x = beta(100, 3, 1.8))
dat <- data.frame(x = rbeta(100, 3, 1.8))
dat
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
head(dat)
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
View(dat)
m <- map2stan(
alist(
x ~ dbetabinom(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
m <- map2stan(
alist(
x ~ dbeta2(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
library(tidyverse)
library(rethinking)
# simulate some proportion data
dat <- data.frame(x = rbeta(100, 3, 1.8))
# fit Beta distributon to data
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
summary(m)
n_samples = 100
post <- extract.samples(m, n_samples)
x <- seq(0,1, 0.01)
y <- dbeta(seq(0,1, 0.01), shape1 = 2, shape2 = 2)
p <- unlist(map2(post$shape1, post$shape2, dbeta, x  = x ))
n <- rep(1:n_samples, each = length(x))
fits <- tibble(x = rep(x, n_samples), p , n = n)
post <- extract.samples(m)
mu <- HPDI(with(post, shape1 / (shape1 + shape2), prob = 0.99))
plt <- ggplot()
plt <- plt + geom_density(data = dat,aes(x = dat$x), fill = "#ec9844", colour = "#ec9844", adjust = 1/2)
plt <- plt + geom_rect(aes(xmin = mu[1], xmax = mu[2], ymin = 0, ymax = Inf), fill = "blue", alpha = 0.3)
plt <- plt + geom_path(data = fits, aes(x = x, y = p, group = n), alpha = 0.1, size = 1)
plt <- plt + scale_x_continuous("proporiton", expand = c(0,0))
plt <- plt + scale_y_continuous("density", expand = c(0,0), limits = c(0, 2))
plt <- plt + theme_bw()
plt
n = 1000
dat <- data.frame(
x = c(rbeta(n, 3, 2), rbeta(n, 1, 2)),
z = rep(0:1, each = n))
plt <- ggplot(dat)
plt <- plt + geom_density(
aes(x = dat$x, fill = as.factor(dat$z)), adjust = 1/2)
plt
head(dat)
library(rethinking)
library(installr)
UpdateR()
updateR()
library(mrgsolve)
mod <- mread("pk2", modlib())
install.packages("mrgre")
install.packages("mrgsolve")
library(mrgsolve)
mod <- mread("pk2", modlib())
install.packages("rstan", type = "source")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", type = "source")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", type = "source")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
remove.packages("rstantools")
if (file.exists(".RData")) file.remove(".RData")
Sys.getenv("PATH")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
a <- 1
a += 1
a =+ 1
a
setwd("E:/Github/Motivation_and_Decisions/Analysis")
#### modelling penguin ####
# This script is to work on modelling the data
# from the penguin version of the task with other
# control versions (using instructed and practice from
# the transfer paper)
#### Library ####
library(brms)
library(rethinking)
library(rstan)
library(tidybayes)
library(tidyverse)
#### constants ####
Screen_dist <- 60
x_res <- 1920
x_width <- 54
ppcm <- x_res/x_width
#### Functions ####
# get visual degrees
get_VisDegs <- function(size,distance){
((2*atan2(size,(2*distance)))*180)/pi
}
# get posterior preds for beta dist
post_preds_beta <- function(m, x, m_matrix){
post <- rstan::extract(m)
beta <- colMeans(post$beta)
gamma <- colMeans(post$gamma)
mu  <- plogis(m_matrix %*% beta)
phi <- exp(m_matrix %*% gamma)
A <- mu * phi
B <- (1 - mu) * phi
p <- unlist(map2(A, B, dbeta, x = x_vals))
return(p)
}
# plotting mean output from stan
make_plt <- function(model_output, dataframe, dist_true){
output <- as.tibble(model_output) %>%
gather(key = "remove",
value = "pred_mu") %>%
group_by(remove) %>%
mutate(row_num = strsplit(remove, split = "V")[[1]][2]) %>%
ungroup() %>%
select(-remove) %>%
merge(dataframe) %>%
ggplot(aes(pred_mu,
colour = group,
fill = group)) +
geom_density(alpha = 0.3) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
if(dist_true == T){
output <- output + facet_wrap(~dist_type)
}
return(output)
}
#### load in data ####
load("scratch/all_data")
df_all <- df
#tidy
rm(df)
# work out expected accuracy?
# motivated
load("scratch/acc_sep_peng")
acc_sep_peng <- acc_sep %>%
mutate(participant = paste(participant,
"motivated",
sep = "_"))
# control + optimal
load("scratch/acc_sep_contopt")
load("scratch/df_groupID")
acc_sep <- merge(acc_sep, df_groupID) %>%
mutate(participant = paste(participant, group, sep = "_")) %>%
select(-group) %>%
rbind(acc_sep_peng)
# tidy
rm(acc_sep_peng)
# bind this to df
# need to figure out distances... before binding...
acc_sep_1 <- acc_sep %>%
mutate(separation_1 = separation,
accuracy_1 = accuracy) %>%
select(-separation, -accuracy)
acc_sep_2 <- acc_sep %>%
mutate(separation_2 = separation,
accuracy_2 = accuracy) %>%
select(-separation, -accuracy)
df_all <- df_all %>%
mutate(separation_1 = separation*centre,
separation_2 = (separation*2)-separation_1)
# merge this
df_all<- merge(df_all, acc_sep_1)
df_all<- merge(df_all, acc_sep_2) %>%
mutate(accuracy = (accuracy_1 + accuracy_2)/2) %>%
select(-separation_1, -separation_2,
-accuracy_1, -accuracy_2)
# tidy
rm(acc_sep_1, acc_sep_2)
#### remove participant that didn't complete 4 blocks ####
df_all <- df_all %>%
group_by(participant) %>%
filter(max(block) == 4)
# plot something to check
df_all%>%
group_by(participant, group) %>%
summarise(predicted = mean(accuracy),
actual = mean(correct)) %>%
gather(predicted:actual,
key = "type",
value = "accuracy") %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_density(alpha = 0.3) +
theme_minimal() +
facet_wrap(~type)
model_data_2 <- df_all%>%
group_by(participant, group) %>%
summarise(accuracy = mean(correct))
m_matrix <- model.matrix(accuracy ~ group, data = model_data_2)
# setup data for plotting
model_data_new <- model_data_2 %>%
rownames_to_column(var = "row_num")
stan_df <- list(
N = nrow(model_data_2),
K = ncol(m_matrix),
y = model_data_2$accuracy,
X = m_matrix
)
m_stan_group <- stan(
file = "modelling/models/stan_model.stan",
data = stan_df,
chains = 1,
warmup = 1000,
iter = 2000,
refresh = 100
)
# extract samples
samples <- rstan::extract(m_stan_group)
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram() +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge") +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bindwidth = 50) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bindwidth = 100) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 100) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 10) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 5) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_posterior <- tibble(
Group = rep(unique(model_data_2$group), each = length(x_vals)),
x = rep(x_vals, 3),
p = post_preds_beta(m_stan_group, x_vals, X)) %>%
ggplot(aes(x, p, colour = Group, fill = Group)) +
#geom_line(aes(group = Group)) +
geom_area(position = "dodge", alpha = 0.3) +
theme_minimal() +
scale_x_continuous(limits = c(0.5, 0.9)) +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
theme(legend.position = "bottom")
plt_posterior$labels$x <- "Predicted Mean Accuracy"
plt_posterior$labels$y <- "density"
plt_posterior
X <- tibble(intercept = c(1,1,1),
motivated = c(0,1,0),
optimal = c(0,0,1))
X <- as.matrix(X)
# sequence to estimate likelihood
x_vals <- seq(0,1,0.0001)
# plt posterior
plt_posterior <- tibble(
Group = rep(unique(model_data_2$group), each = length(x_vals)),
x = rep(x_vals, 3),
p = post_preds_beta(m_stan_group, x_vals, X)) %>%
ggplot(aes(x, p, colour = Group, fill = Group)) +
#geom_line(aes(group = Group)) +
geom_area(position = "dodge", alpha = 0.3) +
theme_minimal() +
scale_x_continuous(limits = c(0.5, 0.9)) +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
theme(legend.position = "bottom")
plt_posterior$labels$x <- "Predicted Mean Accuracy"
plt_posterior$labels$y <- "density"
plt_posterior
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 5) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() %>%
gridExtra::grid.arrange(plt_posterior, ncol = 2)
plt_both
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 5) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both <- gridExtra::grid.arrange(plt_both, plt_posterior, ncol = 2)
plt_both <- gridExtra::grid.arrange(plt_both, plt_posterior, nrow = 2)
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "dodge",
bins = 5) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both <- gridExtra::grid.arrange(plt_both, plt_posterior, nrow = 2)
# compare with real data
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "identity",
bins = 5) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "identity",
bins = 10) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "identity",
bins = 10,
alpha = 0.4) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both
plt_both <- gridExtra::grid.arrange(plt_both, plt_posterior, nrow = 2)
plt_both <- model_data_2 %>%
ggplot(aes(accuracy, colour = group, fill = group)) +
geom_histogram(position = "identity",
bins = 20,
alpha = 0.4) +
theme_minimal() +
theme(legend.position = "bottom") +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt_both
plt_both <- gridExtra::grid.arrange(plt_both, plt_posterior, nrow = 2)
